{
	"definitions": {
		"formatter.config.WrappingType": {
			"enum": [
				"onePerLine",
				"onePerLineAfterFirst",
				"equalNumber",
				"fillLine",
				"fillLineWithLeadingBreak",
				"noWrap",
				"keep"
			],
			"markdownEnumDescriptions": [
				"every item in a separate line, including first item",
				"every item in a separate line, except first item",
				"put an equal amount of items per line - not yet implemented",
				"fill each line until maxLineLength - does not start with a newline",
				"fill each line until maxLineLength, starts with a newline before first item",
				"do not wrap items",
				"use wrapping information from source"
			]
		},
		"formatter.config.WrappingLocation": {
			"enum": [
				"beforeLast",
				"afterLast"
			]
		},
		"formatter.config.WrapRules": {
			"additionalProperties": false,
			"properties": {
				"rules": {
					"items": {
						"$ref": "#/definitions/formatter.config.WrapRule"
					},
					"markdownDescription": "list of wrapping rules\nwrapping uses only the first rule whose conditions evaluates to true",
					"type": "array"
				},
				"defaultWrap": {
					"default": "noWrap",
					"markdownDescription": "default wrapping type when no rule applies",
					"$ref": "#/definitions/formatter.config.WrappingType"
				},
				"defaultLocation": {
					"default": "afterLast",
					"markdownDescription": "default wrapping location before / after last token",
					"$ref": "#/definitions/formatter.config.WrappingLocation"
				},
				"defaultAdditionalIndent": {
					"default": 0,
					"markdownDescription": "adds indentation to all wrapped lines when applying defaultWrap",
					"type": "integer"
				}
			},
			"type": "object"
		},
		"formatter.config.WrapRule": {
			"additionalProperties": false,
			"properties": {
				"type": {
					"markdownDescription": "wrapping type",
					"$ref": "#/definitions/formatter.config.WrappingType"
				},
				"location": {
					"default": "afterLast",
					"markdownDescription": "default wrapping location before / after last token",
					"$ref": "#/definitions/formatter.config.WrappingLocation"
				},
				"conditions": {
					"items": {
						"$ref": "#/definitions/formatter.config.WrapCondition"
					},
					"markdownDescription": "list of conditions\nwrapping selects a rule if all of its conditions evaluate to true",
					"type": "array"
				},
				"additionalIndent": {
					"default": 0,
					"markdownDescription": "adds indentation to all wrapped lines",
					"type": "integer"
				}
			},
			"required": [
				"conditions",
				"type"
			],
			"type": "object"
		},
		"formatter.config.WrapConfig": {
			"additionalProperties": false,
			"properties": {
				"typeParameter": {
					"markdownDescription": "type parameter wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"opBoolChain": {
					"markdownDescription": "OpBool chain wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"opAddSubChain": {
					"markdownDescription": "chain wrapping rules for OpAdd / OpSub",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"objectLiteral": {
					"markdownDescription": "object literal wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"multiVar": {
					"markdownDescription": "chain wrapping rules for OpAdd / OpSub",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"methodChain": {
					"markdownDescription": "method chaining wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"metadataCallParameter": {
					"markdownDescription": "metadata call parameter wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"maxLineLength": {
					"default": 160,
					"markdownDescription": "maximum characters per line, formatter will try to wrap code longer than `maxLineLength`",
					"type": "integer"
				},
				"implementsExtends": {
					"markdownDescription": "implements / extends chain wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"functionSignature": {
					"markdownDescription": "named function signature wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"casePattern": {
					"markdownDescription": "chain wrapping rules for case patterns",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"callParameter": {
					"markdownDescription": "call parameter wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"arrayWrap": {
					"markdownDescription": "array wrapping rules\ndoes not affect array comprehension, use \"sameLine.comprehensionFor\"",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"arrayMatrixWrap": {
					"default": "matrixWrapWithAlign",
					"markdownDescription": "detect arrays in matrix configuration from source\nnoMatrixWrap = no detection\nmatrixWrapNoAlign = detect and format as matrix without alignment\nmatrixWrapWithAlign = detect and format as matrix and align columns",
					"$ref": "#/definitions/formatter.config.ArrayMatrixWrap"
				},
				"anonType": {
					"markdownDescription": "anon types wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"anonFunctionSignature": {
					"markdownDescription": "anon function signature wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				}
			},
			"type": "object"
		},
		"formatter.config.WrapConditionType": {
			"enum": [
				"itemCount >= n",
				"itemCount <= n",
				"anyItemLength >= n",
				"anyItemLength <= n",
				"totalItemLength >= n",
				"totalItemLength <= n",
				"lineLength >= n",
				"lineLength <= n",
				"hasMultilineItems",
				"exceedsMaxLineLength"
			],
			"markdownEnumDescriptions": [
				"condition matches if item count is larger than or equal n characters",
				"condition matches if item count is less than or equal n characters",
				"condition matches if max item length is larger than or equal n characters",
				"condition matches if max item length is less than or equal n characters",
				"condition matches if total length of all wrapable items is larger than or equal n characters",
				"condition matches if total length of all wrapable items is less than or equal n characters",
				"condition matches lines larger than or equal n characters",
				"condition matches lines less than or equal n characters",
				"condition value = 1 matches if line contains a multiline token (string literal, block comment)\nvalue = 0 matches if no multiline token is present",
				"condition value = 1 matches if unwrapped line exceeds maxLineLength\nvalue = 0 matches unwrapped lines not exceeding maxLineLength"
			]
		},
		"formatter.config.WrapCondition": {
			"additionalProperties": false,
			"properties": {
				"value": {
					"default": 1,
					"type": "integer"
				},
				"cond": {
					"$ref": "#/definitions/formatter.config.WrapConditionType"
				}
			},
			"required": [
				"cond"
			],
			"type": "object"
		},
		"formatter.config.WhitespacePolicy": {
			"enum": [
				"none",
				"before",
				"noneBefore",
				"onlyBefore",
				"after",
				"onlyAfter",
				"noneAfter",
				"around"
			]
		},
		"formatter.config.WhitespaceConfig": {
			"additionalProperties": false,
			"properties": {
				"whilePolicy": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"typeParamOpenPolicy": {
					"default": "none",
					"markdownDescription": "\"<\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"typeParamClosePolicy": {
					"default": "none",
					"markdownDescription": "\">\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"typeHintColonPolicy": {
					"default": "none",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"typeExtensionPolicy": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"typeCheckColonPolicy": {
					"default": "around",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"tryPolicy": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"ternaryPolicy": {
					"default": "around",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"switchPolicy": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"semicolonPolicy": {
					"default": "onlyAfter",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"parenConfig": {
					"markdownDescription": "\"(\" + \")\"",
					"$ref": "#/definitions/formatter.config.ParenWhitespaceConfig"
				},
				"openingBracketPolicy": {
					"default": "noneAfter",
					"markdownDescription": "\"[\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"objectFieldColonPolicy": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"intervalPolicy": {
					"default": "none",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"ifPolicy": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"functionTypeHaxe4Policy": {
					"default": "around",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"functionTypeHaxe3Policy": {
					"default": "none",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"formatStringInterpolation": {
					"default": true,
					"markdownDescription": "should formatter try to format string interpolation expressions (e.g. '${x+3}' -> '${x + 3}')\nonly applies spaces, no newlines or wrapping",
					"type": "boolean"
				},
				"forPolicy": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"dotPolicy": {
					"default": "none",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"doPolicy": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"compressSuccessiveParenthesis": {
					"default": true,
					"markdownDescription": "should formatter compress spaces for successive parenthesis `( [ {` vs. `([{`",
					"type": "boolean"
				},
				"commaPolicy": {
					"default": "onlyAfter",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"colonPolicy": {
					"default": "none",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"closingBracketPolicy": {
					"default": "none",
					"markdownDescription": "\"]\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"catchPolicy": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"caseColonPolicy": {
					"default": "onlyAfter",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"bracesConfig": {
					"markdownDescription": "\"{\" + \"}\"",
					"$ref": "#/definitions/formatter.config.BracesWhitespaceConfig"
				},
				"binopPolicy": {
					"default": "around",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"arrowFunctionsPolicy": {
					"default": "around",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"addLineCommentSpace": {
					"default": true,
					"markdownDescription": "ensure a space after '//'",
					"type": "boolean"
				}
			},
			"type": "object"
		},
		"formatter.config.TypedefFieldsEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"existingBetweenFields": {
					"default": "keep",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy"
				},
				"endType": {
					"default": 0,
					"markdownDescription": "add empty lines before closing \"}\" of type",
					"type": "integer"
				},
				"betweenFields": {
					"default": 0,
					"type": "integer"
				},
				"beginType": {
					"default": 0,
					"markdownDescription": "add empty lines after opening \"{\" of type",
					"type": "integer"
				}
			},
			"type": "object"
		},
		"formatter.config.SharpLineEndPolicy": {
			"enum": [
				"none",
				"after"
			]
		},
		"formatter.config.SameLinePolicy": {
			"enum": [
				"same",
				"next",
				"keep"
			]
		},
		"formatter.config.SameLineConfig": {
			"additionalProperties": false,
			"properties": {
				"whileBody": {
					"default": "next",
					"markdownDescription": "same line policy for non block body of \"while\" (not \"do…while\")\n* same = place while and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"untypedBody": {
					"default": "same",
					"markdownDescription": "same line policy for untyped {…} as a body\n* same = place return and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"tryCatch": {
					"default": "same",
					"markdownDescription": "same line policy for \"catch\" part of \"try…catch\"\n* same = place function and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"tryBody": {
					"default": "next",
					"markdownDescription": "same line policy for non block body of \"try\"\n* same = place try and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"returnBodySingleLine": {
					"default": "same",
					"markdownDescription": "same line policy for single line expression return values\n* same = place return and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"returnBody": {
					"default": "same",
					"markdownDescription": "same line policy for multiline expression return values\n* same = place return and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"ifElse": {
					"default": "same",
					"markdownDescription": "same line policy for \"else\" part of \"if…else\"\n* same = place else and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"ifBody": {
					"default": "next",
					"markdownDescription": "same line policy for non block body of \"if\"\n* same = place if and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"functionBody": {
					"default": "next",
					"markdownDescription": "same line policy for non block body of \"function\"\n* same = place function and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"forBody": {
					"default": "next",
					"markdownDescription": "same line policy for non block body of \"for\"\n* same = place function and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"expressionTry": {
					"default": "same",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"expressionIfWithBlocks": {
					"default": false,
					"markdownDescription": "will place if with one expression in a block in one line (requires \"expressionIf\" = \"same\")\nvar foo = if (bar) { \"\"; } else { \"\"; };",
					"type": "boolean"
				},
				"expressionIf": {
					"default": "same",
					"markdownDescription": "same line policy for non block body of \"if\" in a value place / as expression\n* same = place if and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"expressionCase": {
					"default": "keep",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"elseIf": {
					"default": "same",
					"markdownDescription": "same line policy for \"if\" part of \"else if\"\n* same = place if and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"elseBody": {
					"default": "next",
					"markdownDescription": "same line policy for non block body of \"else\"\n* same = place else and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"doWhileBody": {
					"default": "next",
					"markdownDescription": "same line policy for non block body of \"do…while\"\n* same = place function and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"doWhile": {
					"default": "same",
					"markdownDescription": "same line policy for \"while\" part in \"do…while\"\n* same = place while and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"comprehensionFor": {
					"default": "same",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"catchBody": {
					"default": "next",
					"markdownDescription": "same line policy for non block body of \"catch\"\n* same = place catch and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"caseBody": {
					"default": "next",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				},
				"anonFunctionBody": {
					"default": "same",
					"markdownDescription": "same line policy for non block body of anon \"function\"\n* same = place function and body on same line\n* next = place body on next line\n* keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy"
				}
			},
			"type": "object"
		},
		"formatter.config.RightCurlyLineEndPolicy": {
			"enum": [
				"none",
				"before",
				"after",
				"both"
			]
		},
		"formatter.config.ParenWhitespaceConfig": {
			"additionalProperties": false,
			"properties": {
				"whileConditionParens": {
					"markdownDescription": "parens used for while conditions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"switchConditionParens": {
					"markdownDescription": "parens used for switch conditions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"sharpConditionParens": {
					"markdownDescription": "parens used for sharp conditions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"metadataParens": {
					"markdownDescription": "parens used for metadata",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"ifConditionParens": {
					"markdownDescription": "parens used for if conditions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"funcParamParens": {
					"markdownDescription": "parens used for function parameters",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"forLoopParens": {
					"markdownDescription": "parens used for for loops",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"expressionParens": {
					"markdownDescription": "parens used for expressions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"conditionParens": {
					"markdownDescription": "parens used for conditions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"catchParens": {
					"markdownDescription": "parens used for catch",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"callParens": {
					"markdownDescription": "parens used for calls",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"anonFuncParamParens": {
					"markdownDescription": "parens used for anon function parameters",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				}
			},
			"type": "object"
		},
		"formatter.config.OpenClosePolicy": {
			"additionalProperties": false,
			"properties": {
				"removeInnerWhenEmpty": {
					"default": true,
					"markdownDescription": "\"()\" or \"( )\" - if `openingPolicy` contains `After` or `closingPolicy` contains `Before`",
					"type": "boolean"
				},
				"openingPolicy": {
					"default": "none",
					"markdownDescription": "\"(\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				},
				"closingPolicy": {
					"default": "onlyAfter",
					"markdownDescription": "\")\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy"
				}
			},
			"type": "object"
		},
		"formatter.config.LineEndConfig": {
			"additionalProperties": false,
			"properties": {
				"typedefCurly": {
					"markdownDescription": "line end settings for typedef curlies",
					"$ref": "#/definitions/formatter.config.CurlyLineEndPolicy"
				},
				"sharp": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.SharpLineEndPolicy"
				},
				"rightCurly": {
					"default": "both",
					"markdownDescription": "global right curly line end setting",
					"$ref": "#/definitions/formatter.config.RightCurlyLineEndPolicy"
				},
				"objectLiteralCurly": {
					"markdownDescription": "line end settings for object literal curlies",
					"$ref": "#/definitions/formatter.config.CurlyLineEndPolicy"
				},
				"metadataVar": {
					"default": "none",
					"$ref": "#/definitions/formatter.config.AtLineEndPolicy"
				},
				"metadataType": {
					"default": "none",
					"$ref": "#/definitions/formatter.config.AtLineEndPolicy"
				},
				"metadataOther": {
					"default": "none",
					"$ref": "#/definitions/formatter.config.AtLineEndPolicy"
				},
				"metadataFunction": {
					"default": "none",
					"$ref": "#/definitions/formatter.config.AtLineEndPolicy"
				},
				"leftCurly": {
					"default": "after",
					"markdownDescription": "global left curly line end setting",
					"$ref": "#/definitions/formatter.config.LeftCurlyLineEndPolicy"
				},
				"emptyCurly": {
					"default": "noBreak",
					"markdownDescription": "global empty curlies line end setting",
					"$ref": "#/definitions/formatter.config.EmptyCurlyPolicy"
				},
				"caseColon": {
					"default": "after",
					"$ref": "#/definitions/formatter.config.CaseColonLineEndPolicy"
				},
				"blockCurly": {
					"markdownDescription": "line end settings for block curlies",
					"$ref": "#/definitions/formatter.config.CurlyLineEndPolicy"
				},
				"anonTypeCurly": {
					"markdownDescription": "line end settings for anon type curlies",
					"$ref": "#/definitions/formatter.config.CurlyLineEndPolicy"
				},
				"anonFunctionCurly": {
					"markdownDescription": "line end settings for anon function body curlies",
					"$ref": "#/definitions/formatter.config.CurlyLineEndPolicy"
				}
			},
			"type": "object"
		},
		"formatter.config.LineCommentEmptyLinePolicy": {
			"enum": [
				"keep",
				"one",
				"none"
			]
		},
		"formatter.config.LeftCurlyLineEndPolicy": {
			"enum": [
				"none",
				"after",
				"before",
				"both"
			]
		},
		"formatter.config.KeepEmptyLinesPolicy": {
			"enum": [
				"keep",
				"remove"
			]
		},
		"formatter.config.InterfaceFieldsEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"existingBetweenFields": {
					"default": "keep",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy"
				},
				"endType": {
					"default": 0,
					"markdownDescription": "add empty lines before closing \"}\" of type",
					"type": "integer"
				},
				"betweenVars": {
					"default": 0,
					"type": "integer"
				},
				"betweenFunctions": {
					"default": 0,
					"type": "integer"
				},
				"beginType": {
					"default": 0,
					"markdownDescription": "add empty lines after opening \"{\" of type",
					"type": "integer"
				},
				"afterVars": {
					"default": 0,
					"type": "integer"
				}
			},
			"type": "object"
		},
		"formatter.config.IndentationConfig": {
			"additionalProperties": false,
			"properties": {
				"trailingWhitespace": {
					"default": false,
					"markdownDescription": "adds trailing whitespace to empty lines by copying indentation from preceeding line",
					"type": "boolean"
				},
				"tabWidth": {
					"default": 4,
					"markdownDescription": "if `character` is set to \"tab\", formatter uses `tabWidth` to calculate absolute line length",
					"type": "integer"
				},
				"indentObjectLiteral": {
					"default": true,
					"type": "boolean"
				},
				"indentComplexValueExpressions": {
					"default": false,
					"markdownDescription": "indent complex value expressions:\n(true)\t\t\t\t\t\t(false)\nar a = if (true)\t\t\tvar a = if (true)\n\t10;\t\t\t\t\t\t10;\nelse\t\t\t\t\telse\n\t20;\t\t\tvs.\t\t\t20;\neturn if (true)\t\t\treturn if (true)\n\t10;\t\t\t\t\t\t10;\nelse\t\t\t\t\telse\n\t20;\t\t\t\t\t\t20;",
					"type": "boolean"
				},
				"indentCaseLabels": {
					"default": true,
					"markdownDescription": "indent case / default labels (true) or keep them on same level as switch (false)",
					"type": "boolean"
				},
				"conditionalPolicy": {
					"default": "aligned",
					"markdownDescription": "only applies to non inlined conditionals\n\"fixedZero\" = all conditional statements should start in column 1\n\"fixedZeroIncrease\" = indentation for conditionals starts at 0 and increases for every level\n\"fixedZeroIncreaseBlocks\" = same as \"fixedZeroIncrease\" but increases only inside blocks, outside it's \"fixedZero\"\n\"aligned\" = conditional statements share indentation of surrounding code\n\"alignedNestedIncrease\" = conditionals align with surrounding code, but will increase indent when nested\n\"alignedIncrease\" = same as \"aligned\" but will increase indent by +1 for enclosed code\n\"alignedDecrease\" = same as \"aligned\" but will decrease indent by -1 for enclosed code",
					"$ref": "#/definitions/formatter.config.ConditionalIndentationPolicy"
				},
				"character": {
					"default": "tab",
					"markdownDescription": "use \"tab\", \" \", \"  \", \"   \", \"    \", etc. to define which character to use",
					"type": "string"
				}
			},
			"type": "object"
		},
		"formatter.config.ImportsEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"betweenImportsLevel": {
					"default": "all",
					"markdownDescription": "restrict betweenImports setting to a specific level\n\"all\" - apply betweenImports to all imports/using entries\n\"firstLevelPackage\" - group imports/using entries using toplevel package names; no empty lines for identical toplevel names\n\"secondLevelPackage\" - group imports/using entries using top- and secondlevel package names; no empty lines for identical toplevel and secondlevel names\n\"thirdLevelPackage\" - group imports/using entries using upto thirdlevel package names\n\"fourthLevelPackage\" - group imports/using entries using upto foruthlevel package names\n\"fifthLevelPackage\" - group imports/using entries using upto fifthlevel package names\n\"fullPackage\" - group imports/using entries using full packages; no empty lines for identical package names",
					"$ref": "#/definitions/formatter.config.BetweenImportsEmptyLinesLevel"
				},
				"betweenImports": {
					"default": 0,
					"markdownDescription": "empty lines between two consecutive import/using lines using betweenImportsLevel",
					"type": "integer"
				},
				"beforeUsing": {
					"default": 1,
					"markdownDescription": "empty lines between import and using lines",
					"type": "integer"
				},
				"beforeType": {
					"default": 1,
					"markdownDescription": "empty lines after import and using section",
					"type": "integer"
				}
			},
			"type": "object"
		},
		"formatter.config.FormatterConfig": {
			"additionalProperties": false,
			"properties": {
				"wrapping": {
					"anyOf": [
						{
							"type": "null"
						},
						{
							"$ref": "#/definitions/formatter.config.WrapConfig"
						}
					]
				},
				"whitespace": {
					"anyOf": [
						{
							"type": "null"
						},
						{
							"$ref": "#/definitions/formatter.config.WhitespaceConfig"
						}
					]
				},
				"sameLine": {
					"anyOf": [
						{
							"type": "null"
						},
						{
							"$ref": "#/definitions/formatter.config.SameLineConfig"
						}
					]
				},
				"lineEnds": {
					"anyOf": [
						{
							"type": "null"
						},
						{
							"$ref": "#/definitions/formatter.config.LineEndConfig"
						}
					]
				},
				"indentation": {
					"anyOf": [
						{
							"type": "null"
						},
						{
							"$ref": "#/definitions/formatter.config.IndentationConfig"
						}
					]
				},
				"excludes": {
					"items": {
						"type": "string"
					},
					"markdownDescription": "regular expressions matching files to exclude from formatting\ndefault is to exclude any `.haxelib`, `.git` and `node_modules` folder",
					"type": "array"
				},
				"emptyLines": {
					"anyOf": [
						{
							"type": "null"
						},
						{
							"$ref": "#/definitions/formatter.config.EmptyLinesConfig"
						}
					]
				},
				"disableFormatting": {
					"default": false,
					"markdownDescription": "turns off formatting for all files in current folder and subfolders\nunless subfolder contains a `hxformat.json`",
					"type": "boolean"
				}
			},
			"type": "object"
		},
		"formatter.config.EnumAbstractFieldsEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"existingBetweenFields": {
					"default": "keep",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy"
				},
				"endType": {
					"default": 0,
					"markdownDescription": "add empty lines before closing \"}\" of type",
					"type": "integer"
				},
				"betweenVars": {
					"default": 0,
					"type": "integer"
				},
				"betweenFunctions": {
					"default": 1,
					"type": "integer"
				},
				"beginType": {
					"default": 0,
					"markdownDescription": "add empty lines after opening \"{\" of type",
					"type": "integer"
				},
				"afterVars": {
					"default": 1,
					"type": "integer"
				}
			},
			"type": "object"
		},
		"formatter.config.EmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"typedefEmptyLines": {
					"$ref": "#/definitions/formatter.config.TypedefFieldsEmptyLinesConfig"
				},
				"maxAnywhereInFile": {
					"default": 1,
					"markdownDescription": "maximum consecutive empty lines anywhere in file - runs last, all empty lines policies are limited to \"maxAnywhereInFile\"",
					"type": "integer"
				},
				"macroClassEmptyLines": {
					"$ref": "#/definitions/formatter.config.ClassFieldsEmptyLinesConfig"
				},
				"lineCommentsBetweenTypes": {
					"default": "keep",
					"markdownDescription": "empty lines for line comments between types",
					"$ref": "#/definitions/formatter.config.LineCommentEmptyLinePolicy"
				},
				"lineCommentsBetweenFunctions": {
					"default": "keep",
					"markdownDescription": "empty lines for line comments between functions",
					"$ref": "#/definitions/formatter.config.LineCommentEmptyLinePolicy"
				},
				"interfaceEmptyLines": {
					"$ref": "#/definitions/formatter.config.InterfaceFieldsEmptyLinesConfig"
				},
				"importAndUsing": {
					"markdownDescription": "empty lines for package, import and using section",
					"$ref": "#/definitions/formatter.config.ImportsEmptyLinesConfig"
				},
				"finalNewline": {
					"default": true,
					"markdownDescription": "adds a final newline",
					"type": "boolean"
				},
				"externClassEmptyLines": {
					"$ref": "#/definitions/formatter.config.InterfaceFieldsEmptyLinesConfig"
				},
				"enumEmptyLines": {
					"$ref": "#/definitions/formatter.config.TypedefFieldsEmptyLinesConfig"
				},
				"enumAbstractEmptyLines": {
					"$ref": "#/definitions/formatter.config.EnumAbstractFieldsEmptyLinesConfig"
				},
				"conditionalsEmptyLines": {
					"$ref": "#/definitions/formatter.config.ConditionalEmptyLinesConfig"
				},
				"classEmptyLines": {
					"$ref": "#/definitions/formatter.config.ClassFieldsEmptyLinesConfig"
				},
				"betweenTypes": {
					"default": 1,
					"markdownDescription": "empty lines between types",
					"type": "integer"
				},
				"betweenSingleLineTypes": {
					"default": 0,
					"markdownDescription": "empty lines between two single line types",
					"type": "integer"
				},
				"betweenMultilineComments": {
					"default": 0,
					"markdownDescription": "Adds empty lines between two consecutive multiline comments",
					"type": "integer"
				},
				"beforeRightCurly": {
					"default": "remove",
					"markdownDescription": "Remove or keep empty lines above \"}\"",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy"
				},
				"beforePackage": {
					"default": 0,
					"markdownDescription": "empty lines before package declaration",
					"type": "integer"
				},
				"beforeDocCommentEmptyLines": {
					"default": "one",
					"markdownDescription": "\"one\" adds one empty line above doc comments\n\"none\" removes all empty lines above doc comments\n\"ignore\" respects empty lines set via \"betweenVars\", \"betweenFunctions\", etc.",
					"$ref": "#/definitions/formatter.config.CommentEmptyLinesPolicy"
				},
				"beforeBlocks": {
					"default": "remove",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy"
				},
				"afterReturn": {
					"default": "remove",
					"markdownDescription": "Remove or keep empty lines below \"return\"",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy"
				},
				"afterPackage": {
					"default": 1,
					"markdownDescription": "empty lines after package declaration",
					"type": "integer"
				},
				"afterLeftCurly": {
					"default": "remove",
					"markdownDescription": "Remove or keep empty lines below \"{\"",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy"
				},
				"afterFileHeaderComment": {
					"default": 1,
					"markdownDescription": "Adds empty lines when file starts with a multiline comment",
					"type": "integer"
				},
				"afterFieldsWithDocComments": {
					"default": "one",
					"markdownDescription": "\"one\" adds one empty line after fields with doc comments\n\"none\" removes all empty lines line fields with doc comments\n\"ignore\" respects empty lines set via \"betweenVars\", \"betweenFunctions\", etc.",
					"$ref": "#/definitions/formatter.config.CommentEmptyLinesPolicy"
				},
				"afterBlocks": {
					"default": "remove",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy"
				},
				"abstractEmptyLines": {
					"$ref": "#/definitions/formatter.config.ClassFieldsEmptyLinesConfig"
				}
			},
			"type": "object"
		},
		"formatter.config.EmptyCurlyPolicy": {
			"enum": [
				"noBreak",
				"break"
			]
		},
		"formatter.config.CurlyLineEndPolicy": {
			"additionalProperties": false,
			"properties": {
				"rightCurly": {
					"default": "both",
					"markdownDescription": "line end options for right curly",
					"$ref": "#/definitions/formatter.config.RightCurlyLineEndPolicy"
				},
				"leftCurly": {
					"default": "after",
					"markdownDescription": "line end options for left curly",
					"$ref": "#/definitions/formatter.config.LeftCurlyLineEndPolicy"
				},
				"emptyCurly": {
					"default": "noBreak",
					"markdownDescription": "line end options for empty curlies",
					"$ref": "#/definitions/formatter.config.EmptyCurlyPolicy"
				}
			},
			"type": "object"
		},
		"formatter.config.ConditionalIndentationPolicy": {
			"enum": [
				"fixedZero",
				"fixedZeroIncrease",
				"fixedZeroIncreaseBlocks",
				"aligned",
				"alignedNestedIncrease",
				"alignedIncrease",
				"alignedDecrease"
			]
		},
		"formatter.config.ConditionalEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"beforeError": {
					"default": 0,
					"type": "integer"
				},
				"beforeEnd": {
					"default": 0,
					"type": "integer"
				},
				"beforeElse": {
					"default": 0,
					"type": "integer"
				},
				"afterIf": {
					"default": 0,
					"type": "integer"
				},
				"afterError": {
					"default": 0,
					"type": "integer"
				},
				"afterElse": {
					"default": 0,
					"type": "integer"
				}
			},
			"type": "object"
		},
		"formatter.config.CommentEmptyLinesPolicy": {
			"enum": [
				"ignore",
				"none",
				"one"
			]
		},
		"formatter.config.ClassFieldsEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"existingBetweenFields": {
					"default": "keep",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy"
				},
				"endType": {
					"default": 0,
					"markdownDescription": "add empty lines before closing \"}\" of type",
					"type": "integer"
				},
				"betweenVars": {
					"default": 0,
					"type": "integer"
				},
				"betweenStaticVars": {
					"default": 0,
					"type": "integer"
				},
				"betweenStaticFunctions": {
					"default": 1,
					"type": "integer"
				},
				"betweenFunctions": {
					"default": 1,
					"type": "integer"
				},
				"beginType": {
					"default": 0,
					"markdownDescription": "add empty lines after opening \"{\" of type",
					"type": "integer"
				},
				"afterVars": {
					"default": 1,
					"type": "integer"
				},
				"afterStaticVars": {
					"default": 1,
					"type": "integer"
				},
				"afterStaticFunctions": {
					"default": 1,
					"type": "integer"
				},
				"afterPrivateVars": {
					"default": 1,
					"type": "integer"
				},
				"afterPrivateFunctions": {
					"default": 1,
					"type": "integer"
				}
			},
			"type": "object"
		},
		"formatter.config.CaseColonLineEndPolicy": {
			"enum": [
				"none",
				"after"
			]
		},
		"formatter.config.BracesWhitespaceConfig": {
			"additionalProperties": false,
			"properties": {
				"unknownBraces": {
					"markdownDescription": "unknown braces",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"typedefBraces": {
					"markdownDescription": "braces for typdefs",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"objectLiteralBraces": {
					"markdownDescription": "braces for object literals",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"blockBraces": {
					"markdownDescription": "braces for blocks",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"anonTypeBraces": {
					"markdownDescription": "braces for anon types",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				}
			},
			"type": "object"
		},
		"formatter.config.BetweenImportsEmptyLinesLevel": {
			"enum": [
				"all",
				"firstLevelPackage",
				"secondLevelPackage",
				"thirdLevelPackage",
				"fourthLevelPackage",
				"fifthLevelPackage",
				"fullPackage"
			]
		},
		"formatter.config.AtLineEndPolicy": {
			"enum": [
				"none",
				"after",
				"afterLast",
				"forceAfterLast"
			]
		},
		"formatter.config.ArrayMatrixWrap": {
			"enum": [
				"noMatrixWrap",
				"matrixWrapNoAlign",
				"matrixWrapWithAlign"
			]
		}
	},
	"$ref": "#/definitions/formatter.config.FormatterConfig",
	"$schema": "http://json-schema.org/draft-07/schema#"
}